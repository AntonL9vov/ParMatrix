import org.matrix.parallel.*
import java.util.concurrent.Executors

fun main(){
    val a = MatrixParallel(8,8, false, 150.0)
    val b = MatrixParallel(8,8, false, 150.0)
    val treadPool =  Executors.newCachedThreadPool()
    var startTime = System.currentTimeMillis()
    var endTime = System.currentTimeMillis()
    println(a)
    println()
    println(b)
    println()
    println("Добавление")
    startTime = System.currentTimeMillis()
    var c = AddParallel().add(a, b, null)
    endTime = System.currentTimeMillis()
    println(c)
    println(endTime-startTime)
    println()
    println("Умножение")
    startTime = System.currentTimeMillis()
    c = MultParallel().multiply(a, b, treadPool)
    endTime = System.currentTimeMillis()
    println(c)
    println(endTime-startTime)
    println()
    println("Скалярное Умножение")
    startTime = System.currentTimeMillis()
    c = ScalarMultParallel().multiply(a, 5.0, treadPool)
    endTime = System.currentTimeMillis()
    println(c)
    println(endTime-startTime)
    println()
    println("Траспонирование")
    startTime = System.currentTimeMillis()
    c = TransposeParallel().transpose(a, treadPool)
    endTime = System.currentTimeMillis()
    println(c)
    println(endTime-startTime)
    println()
    println("Детерминант")
    startTime = System.currentTimeMillis()
    val det = DeterminantParallel().DetNxNParallel(a, treadPool)
    endTime = System.currentTimeMillis()
    println(det)
    println(endTime-startTime)
    println()
    println("LU разложение")
    startTime = System.currentTimeMillis()
    val y = LUDecomposeParallel1D().LUDecompose(a, treadPool)
    endTime = System.currentTimeMillis()
    println(y!![0])
    println(y[1])
    println(endTime-startTime)
    println()
    treadPool.shutdown()
}